Let's Go
Class #2

Andrew Lader
Senior Technical Principal, Sirrus7
andrew@sirrus7.com

* So, Let's Go!

*Agenda*

- Examine the Homework
- Go Routines & Channels Baby!!!
- Homework

* What did we learn from the Homework?

- How to structure your app
- How to model objects in Go
- Enums in Go
- Slice initializations (random?)
- How to use builtin packages (rand)
- What Go forces you to do, and why is that good?

* So what in the world is Concurrency? (Go Routines and Channels)

- Let's start with concurrency vs parrallelism

    * Concurrency is about dealing with lots of things at once {structure}
    * Parrallelism is about running lots of things at once {execution}

*Related*, but not exactly the same

.image ./images/concurrency_vs_parallelism.png _ 1259

* Go Provides Concurrent Structure

- Create individual pieces
- Each can work independently
- Use communication to coordinate the pieces (channels!)
- Organize the code better

[[https://talks.golang.org/2012/waza.slide][Concurrency is not Parallelism]]

* Go Routines and Channels

*Go*Routines*

- Go routines are a basic element of Go
- They allow the process to spawn a function executing independently
- If the machine allows multiple threads, then it will execute on other threads

*Channels*

- Channels are how Go Routines communicate with one another
- Think of them as synchronised message queues
- Sending and receiving values to and from a channel is a blocking concurrency_vs_parallelism

*Important*

- Order of execution of the Go routines is not guaranteed
- Other ways to control the order of execution, like `select case` and `waitgroup`

[[https://www.linkedin.com/pulse/concurrency-golang-uttam-gandhi][Concurency in Golang]]

* How to: Go Routines and Channels

- To spawn a Go routine:

    go fooBar(args...)

- Nomenclature for channels

    channelOne := make(chan string)
    foo <-channelOne    // blocks waiting to pull the next item from the channel
    channeltwo <- bar   // blocks waiting to add bar to the channel

* Channels

- Go routines are pretty self-explanatory, at least for now...
- Channels require more attention as they are used to communicate across routines
- Channels can be buffered and unbuffered
- Unbuffered channels only have one item _(default)_
- Buffered channels have an allocated amount of items

    channelOne := make(chan int, 10) // create a channel that bufferes 10 integers

- The example above would not block if it had 9 items and the code wanted to add a 10th

[[https://play.golang.org/p/Ph9RjvvhoL][Go Routines and Channels Playground]]

* Exit your App Gracefully!

- So Go routines and channels are awesome, but how does the application exit gracefully?
- We can use `WaitGroups` to wait for all routines to exit before the main proccess exits
- Part of the `sync` package, `WaitGroups` have three main behaviors:

    waitgroup := &sync.WaitGroups
    waitgroup.Add(1)    // can be any integer > 0, incremented when creating new routines
    waitGroup.Done()    // called by a routine right before it exits
    waitGroup.Wait()    // used by the main application to wait for everything to shutdown

* Locks

- Locks can be used to control access to resources (data, databases, etc...)
- They come in two flavors: `Mutex` and `RWMutex`
- `Mutex` allows code to exclusively own a resource until it unlocks it
- `RWMutex` controls the read/write access to a resource, allowing multiple routines to have read access simultaneously, or one writer

    mutex := &sync.Mutex{}
    mutex.Lock()
    mutex.Unlock()

* Resources

[[https://talks.golang.org/2012/waza.slide][Concurrency is not Parallelism]]

[[https://www.linkedin.com/pulse/concurrency-golang-uttam-gandhi][Concurency in Golang]]
